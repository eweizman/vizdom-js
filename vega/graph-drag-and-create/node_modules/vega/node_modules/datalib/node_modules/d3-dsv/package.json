{
  "name": "d3-dsv",
  "version": "0.1.5",
  "description": "A parser and formatter for delimiter-separated values, such as CSV and TSV",
  "keywords": [
    "d3",
    "dsv",
    "csv",
    "tsv"
  ],
  "homepage": "https://github.com/d3/d3-dsv",
  "license": "BSD-3-Clause",
  "author": {
    "name": "Mike Bostock",
    "url": "http://bost.ocks.org/mike"
  },
  "main": "build/dsv",
  "jsnext:main": "index.js",
  "bin": {
    "csv2tsv": "./bin/csv2tsv",
    "csv2json": "./bin/csv2json",
    "tsv2csv": "./bin/tsv2csv",
    "tsv2json": "./bin/tsv2json"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/d3/d3-dsv.git"
  },
  "scripts": {
    "pretest": "mkdir -p build && d3-bundler --format=umd --name=dsv -- index.js > build/dsv.js",
    "test": "faucet `find test -name '*-test.js'`",
    "prepublish": "npm run test && uglifyjs build/dsv.js -c -m -o build/dsv.min.js && rm -f build/dsv.zip && zip -j build/dsv.zip -- LICENSE README.md build/dsv.js build/dsv.min.js"
  },
  "devDependencies": {
    "d3-bundler": "~0.2.5",
    "faucet": "0.0",
    "tape": "4",
    "uglifyjs": "2"
  },
  "readme": "# d3-dsv\n\nA parser and formatter for delimiter-separated values, most commonly [comma-separated values](https://en.wikipedia.org/wiki/Comma-separated_values) (CSV) and tab-separated values (TSV). These tabular formats are popular with spreadsheet programs such as Microsoft Excel, and are often more space-efficient than JSON for large datasets. This implementation is based on [RFC 4180](http://tools.ietf.org/html/rfc4180).\n\nSupports [comma-](#csv) and [tab-](#tsv)separated values out of the box. To define a new delimiter, such as `\"|\"` for pipe-separated values, use the [dsv constructor](#dsv):\n\n```js\nvar psv = dsv(\"|\");\n\nconsole.log(psv.parse(\"foo|bar\\n1|2\")); // [{foo: \"1\", bar: \"2\"}]\n```\n\n<a name=\"dsv\" href=\"#dsv\">#</a> <b>dsv</b>(<i>delimiter</i>)\n\nConstructs a new DSV parser and formatter for the specified *delimiter*.\n\n<a name=\"dsv_parse\" href=\"#dsv_parse\">#</a> *dsv*.<b>parse</b>(<i>string</i>[, <i>row</i>])\n\nParses the specified *string*, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of objects representing the parsed rows.\n\nUnlike [*dsv*.parseRows](#dsv_parseRows), this method requires that the first line of the DSV content contains a delimiter-separated list of column names; these column names become the attributes on the returned objects. For example, consider the following CSV file:\n\n```\nYear,Make,Model,Length\n1997,Ford,E350,2.34\n2000,Mercury,Cougar,2.38\n```\n\nThe resulting JavaScript array is:\n\n```js\n[\n  {\"Year\": \"1997\", \"Make\": \"Ford\", \"Model\": \"E350\", \"Length\": \"2.34\"},\n  {\"Year\": \"2000\", \"Make\": \"Mercury\", \"Model\": \"Cougar\", \"Length\": \"2.38\"}\n]\n```\n\nField values are always strings; they will not be automatically converted to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the `+` operator). By specifying a *row* conversion function, you can convert the strings to numbers or other specific types, such as dates:\n\n```js\nvar data = csv.parse(string, function(d) {\n  return {\n    year: new Date(+d.Year, 0, 1), // convert \"Year\" column to Date\n    make: d.Make,\n    model: d.Model,\n    length: +d.Length // convert \"Length\" column to number\n  };\n});\n```\n\nUsing `+` rather than [parseInt](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt) or [parseFloat](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseFloat) is typically faster, though more restrictive. For example, `\"30px\"` when coerced using `+` returns `NaN`, while parseInt and parseFloat return `30`.\n\n<a name=\"dsv_parseRows\" href=\"#dsv_parseRows\">#</a> <i>dsv</i>.<b>parseRows</b>(<i>string</i>[, <i>row</i>])\n\nParses the specified *string*, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of arrays representing the parsed rows.\n\nUnlike [*dsv*.parse](#dsv_parse), this method treats the header line as a standard row, and should be used whenever DSV content does not contain a header. Each row is represented as an array rather than an object. Rows may have variable length. For example, consider the following CSV file, which notably lacks a header line:\n\n```\n1997,Ford,E350,2.34\n2000,Mercury,Cougar,2.38\n```\n\nThe resulting JavaScript array is:\n\n```js\n[\n  [\"1997\", \"Ford\", \"E350\", \"2.34\"],\n  [\"2000\", \"Mercury\", \"Cougar\", \"2.38\"]\n]\n```\n\nField values are always strings; they will not be automatically converted to numbers. See [*dsv*.parse](#dsv_parse) for details. An optional *row* conversion function may be specified as the second argument to convert types and filter rows. For example:\n\n```js\nvar data = csv.parseRows(string, function(d, i) {\n  return {\n    year: new Date(+d[0], 0, 1), // convert first colum column to Date\n    make: d[1],\n    model: d[2],\n    length: +d[3] // convert fourth column to number\n  };\n});\n```\n\nThe *row* function is invoked for each row in the DSV content, being passed the current rowâ€™s array of field values (`d`) and index (`i`) as arguments. The return value of the function replaces the element in the returned array of rows; if the function returns null or undefined, the row is stripped from the returned array of rows. In effect, *row* is similar to applying a [map](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map) and [filter](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter) operator to the returned rows.\n\n<a name=\"dsv_format\" href=\"#dsv_format\">#</a> <i>dsv</i>.<b>format</b>(<i>rows</i>)\n\nFormats the specified array of object *rows* as delimiter-separated values, returning a string. This operation is the inverse of [*dsv*.parse](#dsv_parse). Each row will be separated by a newline (`\\n`), and each column within each row will be separated by the delimiter (such as a comma, `,`). Values that contain either the delimiter, a double-quote (`\"`) or a newline will be escaped using double-quotes.\n\nThe header row is determined by the union of all properties on all objects in *rows*. The order of header columns is nondeterministic. All properties on each row object will be coerced to strings. For more control over which and how fields are formatted, first map *rows* to an array of array of string, and then use [*dsv*.formatRows](#dsv_formatRows).\n\n<a name=\"dsv_formatRows\" href=\"#dsv_formatRows\">#</a> <i>dsv</i>.<b>formatRows</b>(<i>rows</i>)\n\nFormats the specified array of array of string *rows* as delimiter-separated values, returning a string. This operation is the reverse of [*dsv*.parseRows](#dsv_parseRows). Each row will be separated by a newline (`\\n`), and each column within each row will be separated by the delimiter (such as a comma, `,`). Values that contain either the delimiter, a double-quote (\") or a newline will be escaped using double-quotes.\n\n<a name=\"csv\" href=\"#csv\">#</a> <b>csv</b>\n\nA parser and formatter for comma-separated values (CSV), defined as:\n\n```js\nvar csv = dsv(\",\");\n```\n\n<a name=\"tsv\" href=\"#tsv\">#</a> <b>tsv</b>\n\nA parser and formatter for tab-separated values (TSV), defined as:\n\n```js\nvar tsv = dsv(\"\\t\");\n```\n\n### Content Security Policy\n\nIf a [content security policy](http://www.w3.org/TR/CSP/) is in place, note that [*dsv*.parse](#dsv_parse) requires `unsafe-eval` in the `script-src` directive, due to the (safe) use of dynamic code generation for fast parsing. (See [source](https://github.com/d3/d3-dsv/blob/master/src/dsv.js).) Alternatively, use [*dsv*.parseRows](#dsv_parseRows).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/d3/d3-dsv/issues"
  },
  "_id": "d3-dsv@0.1.5",
  "_from": "d3-dsv@latest"
}
